import json
import traceback
from abc import ABC, abstractmethod
from enum import Enum
from typing import Optional, Dict, Set, Union

import demistomock as demisto

try:
    from CommonServerPython import ThreatIntel, argToBoolean, CommandResults, return_results, return_error, Common
except:  # todo remove
    print("XSOAR")
    pass

SUPPORTED_HASHES = 'SHA256', 'SHA512', 'SHA1', 'MD5'
CONTEXT_FINDING_PREFIX = 'MalwareFinding.ContextFinding'
FILE_FINDING_PREFIX = 'MalwareFinding.FileFinding'


def get(value: dict, key: str) -> set:
    """
    Fetches a value, entering lists when necessary:
    >>> get({'foo': {'inner':'value'}}, 'foo.bar') # returns None
    >>> get({'foo': {'inner':'value'}}, 'foo.inner')
    {'value'}
    >>> sorted(list(get({'foo': [{'inner': 'value2'}, {'inner': 'value1'}, {'bar':'baz'}]}, 'foo.inner')))
    ['value1', 'value2']
    """
    parts = key.split(".")
    for i, part in enumerate(parts):
        if isinstance(value, dict):
            if part in value:
                value = value[part]
                if i == len(parts) - 1:
                    return {value}
            else:
                break  # causes None to be returned
        elif isinstance(value, list) and isinstance(value[0], dict) and i != len(parts):
            # NOTE: removes None values!
            next_values = set()
            for sub_dict in value:
                next_values.update(get(sub_dict, ".".join(parts[i:])) or {})
            return set(filter(None, next_values))


class Status(Enum):
    SUSPICIOUS = 2
    BENIGN = 1
    UNKNOWN = 0


class Source(Enum):
    SANDBOX = 'Sandbox'
    EDR = 'EDR'


DBOT_TO_STRING = {0: 'Unknown',
                  1: 'Good',
                  2: 'Suspicious',
                  3: 'Bad'}


class MalwareFinding(ABC):
    name: str
    context: dict
    question: Optional[str]
    status: Optional[Status]
    sources: Set[Source]
    additional_attributes: Optional[Dict[str, str]] = {}

    def __init__(self, name: str, context: dict, question: Optional[str] = None):
        """
        Represents a query to the context.
        :param name: Name of the query
        :param context: Context to search in.
        :param question: The question this query answers, as it's shown to the user.
        """
        self.name = name
        self.context = context
        self.question = question
        self.status = Status.UNKNOWN  # default
        self.sources = set()

        self._parse_context()

    def to_context(self, include_hashes: bool) -> dict:
        """
        Creates a context section from the finding.
        :param include_hashes: whether to include the hashes related to this file in the context.
        Use `False` when creating context for aggregated results (max of findings)
        :return: a dictionary to be used as CommandResult.output.
        """
        context = {}

        if self.sources:
            # sources are not always defined, e.g. in Verdict.
            context['Sources'] = sorted([source.value for source in self.sources])  # sorting for deterministic results

        if self.question:
            context['Question'] = self.question

        if self.status:
            context['Status'] = self.status.name.title()  # e.g. Benign rather than BENIGN

        if include_hashes:
            for hash_name in sorted(SUPPORTED_HASHES):
                if hash_value := self.context.get(hash_name):
                    context[hash_name] = hash_value

        if self.additional_attributes:
            context |= self.additional_attributes

        return context

    def _process_value(self, value: str, expected_value: Union[str, bool], status: Status, source: Source):
        """
        Compares the value to an expected value.
        If the two are equal, the status and source are set accordingly.
        """
        if isinstance(expected_value, bool):
            try:
                value = argToBoolean(value)
            except ValueError:
                return  # if a value can't be converted to bool, it is definitely not the expected boolean.

        if value == expected_value:
            self.status = status
            self.sources.add(source)
            # not using break here, in case there are multiple sources

    def _parse_key(self, key: str, expected_value: Union[str, bool], status: Status, source: Source,
                   context: dict = None):
        if context is None:
            context = self.context

        for value in get(context, key) or {}:
            self._process_value(value, expected_value, status, source)

    @abstractmethod
    def _parse_context(self) -> None:
        """
        Determines all class attribute values (status, sources, etc.) from the context.
        Naturally, this is customized in each inheriting class.
        """
        raise NotImplemented(f'Missing implementation of _parse_context() for {self.name}')


class KillChain(MalwareFinding, ABC):
    def __init__(self, name: str, question: str, context: dict, search_value: str):
        self.search_value = search_value
        super().__init__(name=name, question=question, context=context)  # calls self._parse_context

    def _parse_context(self) -> None:
        self._parse_key('csfalconx.resource.sandbox.mitre_attacks.tactic', self.search_value,
                        Status.SUSPICIOUS, Source.SANDBOX)
        self._parse_key('incident.tacticname', self.search_value, Status.SUSPICIOUS, Source.EDR)
        self._parse_key('AttackPattern.KillChainPhases', self.search_value, Status.SUSPICIOUS, Source.EDR)


class Persistence(KillChain):
    def __init__(self, context: dict):
        super().__init__(
            name='EvidenceOfPersistence',
            question='Is there evidence of Persistence?',
            context=context,
            search_value=ThreatIntel.KillChainPhases.PERSISTENCE
        )


class DefenseEvasion(KillChain):
    def __init__(self, context: dict):
        super().__init__(
            name='EvidenceOfDefenseEvasion',
            question='Is there evidence of Defense Evasion?',
            context=context,
            search_value=ThreatIntel.KillChainPhases.DEFENSE_EVASION
        )


class Execution(KillChain):
    def __init__(self, context: dict):
        super().__init__(
            name='EvidenceOfExecution',
            question='Is there evidence of Execution?',
            context=context,
            search_value=ThreatIntel.KillChainPhases.EXECUTION
        )


class LateralMovement(KillChain):
    def __init__(self, context: dict):
        super().__init__(
            name='EvidenceOfLateralMovement',
            question='Is there evidence of Lateral Movement?',
            context=context,
            search_value=ThreatIntel.KillChainPhases.LATERAL_MOVEMENT
        )


class PrivilegeEscalation(KillChain):
    def __init__(self, context: dict):
        super().__init__(
            name='EvidenceOfPrivilegeEscalation',
            question='Is there evidence of Privilege Escalation?',
            context=context,
            search_value=ThreatIntel.KillChainPhases.PRIVILEGE_ESCALATION
        )


class CommandAndControl(KillChain):
    def __init__(self, context: dict):
        super().__init__(
            name='EvidenceOfCommandAndControl',
            question='Is there evidence of Command and Control?',
            context=context,
            search_value=ThreatIntel.KillChainPhases.COMMAND_AND_CONTROL
        )


class FileSignature(MalwareFinding):
    def _parse_context(self) -> None:
        self.file_context = {}
        self.additional_attributes = {}
        self.status = Status.SUSPICIOUS  # default

        # MSDE
        self._parse_key('IsValidCertificate', True, Status.BENIGN, Source.EDR, context=self.microsoft_atp_context)

        if signer := demisto.get(self.microsoft_atp_context, 'Signer'):
            self.additional_attributes['Signer'] = signer
            self.sources.add(Source.EDR)

        # WildFire
        elif publisher := demisto.get(self.file_context, 'Signature.Publisher'):
            self.status = Status.BENIGN
            self.additional_attributes['Signer'] = publisher
            self.sources.add(Source.SANDBOX)

    def __init__(self, context: dict, hash_key: str, hash_value: str):
        self.hash_key = hash_key  # e.g. SHA256
        self.hash_value = hash_value
        self.file_context = {}

        for file in context.get('File', []):
            if file.get('hash_key') == hash_value:
                self.file_context = file
                break

        self.microsoft_atp_context = {}
        for file in context.get('MicrosoftATP.File', []):
            if microsoft_hash := {'SHA1': 'Sha1', 'MD5': 'Md5', 'SHA256': 'Sha256'}.get(self.hash_key):
                if file.get(microsoft_hash) == self.hash_value:
                    self.microsoft_atp_context = file
                    break

        super().__init__(name='FileDigitalSignature',
                         question='Is the file digitally signed?',
                         context=context)


class Verdict(MalwareFinding):
    def _parse_context(self) -> None:
        dbot_scores = self.context.get('DBotScore', [])
        if isinstance(dbot_scores, dict):  # may be a single dict, or a list of dicts
            dbot_scores = [dbot_scores]

        for dbot_score in dbot_scores:
            if dbot_score.get('Indicator') == self.hash_value:
                self.dbot_score = int(dbot_score.get('Score', 0))
                self.sources.add(Source.SANDBOX)
                if vendor := dbot_score.get('Vendor'):
                    self.vendor = vendor
                break
        else:  # when self.hash_value was not found
            raise ValueError(f'Could not find DBotScore for {self.hash_value}')

    def __init__(self, context: dict, hash_key: str, hash_value: str):
        self.hash_value = hash_value
        self.dbot_score: int = Common.DBotScore.NONE  # default, modified in _parse_context
        self.vendor: Optional[str] = None
        self.additional_attributes['Indicator'] = self.hash_value
        self.additional_attributes['DBotScore'] = DBOT_TO_STRING.get(self.dbot_score)
        super().__init__(name='SandboxVerdict', question='Sandbox Verdict', context=context)

    def to_context(self, include_hashes: bool) -> dict:
        if self.vendor:
            self.additional_attributes['Vendor'] = self.vendor
        return super().to_context(include_hashes=include_hashes)


def parse_context(context: dict) -> list[CommandResults]:
    return [CommandResults(outputs_prefix=f'{CONTEXT_FINDING_PREFIX}.{finding.name}',
                           outputs=finding.to_context(include_hashes=False))
            for finding in (
                Persistence(context),
                DefenseEvasion(context),
                Execution(context),
                LateralMovement(context),
                PrivilegeEscalation(context),
                CommandAndControl(context),
            )]


def create_file_findings(context: dict) -> dict[str, list[MalwareFinding]]:
    findings = {
        'FileSignature': [],
        'Verdict': [],
    }

    for file_entry in context.get('File', []):
        for hash_key in SUPPORTED_HASHES:
            if hash_value := file_entry.get(hash_key):
                findings['FileSignature'].append(FileSignature(file_entry, hash_key, hash_value))
                findings['Verdict'].append(Verdict(file_entry, hash_key, hash_value))
            break
        else:
            demisto.debug(f'Could not find hash for file {file_entry}')

    return findings


def parse_files(context: dict) -> list[CommandResults]:
    findings: dict[str, list[MalwareFinding]] = create_file_findings(context)  # {'Verdict': [...]}
    file_finding_results: list[CommandResults] = []

    for finding_type, findings_ in findings.items():
        for finding in findings_:
            file_finding_results.append(CommandResults(outputs_prefix=f'{FILE_FINDING_PREFIX}.{finding.name}',
                                                       outputs=finding.to_context(include_hashes=True),
                                                       outputs_key_field=finding.hash_key))

    max_findings = []

    if verdicts := findings.get('Verdict'):
        max_findings.append(max(verdicts, key=lambda _: _.dbot_score))
    if signatures := findings.get('FileSignature'):
        max_findings.append(max(signatures, key=lambda _: int(_.status.value)))

    for finding in max_findings:
        file_finding_results.append(
            CommandResults(outputs_prefix=f'{CONTEXT_FINDING_PREFIX}.{finding.name}',
                           outputs=finding.to_context(include_hashes=False))
            # include_hashes is relevant for file-specific results, not for the aggregated maximal
        )
    return file_finding_results


def parse_command(context: dict) -> list[CommandResults]:
    return parse_context(context) + parse_files(context)


def main():
    try:
        context = demisto.callingContext.get('context', {}).get('ExecutionContext', {})
        # context = json.load(open('test_data/dummy_json.json'))  # todo remove
        result = parse_command(context)  # todo remove
        return_results(result)

    except Exception as e:
        demisto.error(traceback.format_exc())  # print the traceback
        return_error(f'Failed to execute Parse. Error: {str(e)}')


if __name__ == '__main__':
    main()
