import json
from pathlib import Path
from typing import Union

import pytest

from CommonServerPython import CommandResults
from Parse import parse_command, KillChain, Status, Source, Verdict

TEST_DATA_DIR = Path(__file__).parent / 'test_data'


def _to_context(command_results: list[CommandResults]):
    return [result.to_context() for result in command_results]


def _dump_test_file(file_name: str, content: dict):
    (TEST_DATA_DIR / file_name).write_text(json.dumps(content))


def _load_test_file(file_name: str):
    return json.loads((TEST_DATA_DIR / file_name).read_text())


def test_empty():
    """
    Given   an empty context
    When    calling parse_command
    Then    make sure the result is the default
    """
    assert _to_context(parse_command(context={})) == _load_test_file('empty_context.json')


@pytest.mark.parametrize('mocked_context,status,sources,search_value,test_index',
                         [
                             ({}, Status.UNKNOWN, set(), '', 0),
                             ({'incident': {'tacticname': 'hello'}}, Status.SUSPICIOUS, {Source.EDR}, 'hello', 1),
                             ({'incident': {'tacticname': 'hello'},
                               'csfalconx': {'resource': {'sandbox': {'mitre_attacks': {'tactic': 'hello'}}}}},
                              Status.SUSPICIOUS, {Source.SANDBOX, Source.EDR}, 'hello', 2),
                         ])
def test_kill_chain(mocked_context: dict, status: Status, sources: set[Source], search_value: str, test_index: int):
    """
    Given   a class inheriting from KillChain
    When    instantiating
    Then    check the result of KillChain._parse_context
    """

    class NewKillChain(KillChain):
        def __init__(self, context: dict):
            super().__init__(
                name='dummy',
                question='Is there life on mars?',
                context=context,
                search_value=search_value
            )

    test_object = NewKillChain(mocked_context)

    assert test_object.status == status
    assert test_object.sources == sources
    assert test_object.to_context(False) == _load_test_file(f'kill_chain_{test_index}.json')


@pytest.mark.parametrize('vendor', ['', 'Vendors INC'])
@pytest.mark.parametrize('score', (0, '1'))
def test_verdict(vendor: str, score: Union[str, int]):
    context = {'DBotScore': [{'Indicator': 'sha256',
                              'Vendor': vendor,
                              'Score': score}]
               }
    verdict = Verdict(context, hash_key='sha256', hash_value='sha256')
    assert verdict.dbot_score == int(score)
    assert verdict.vendor == (vendor or None)
    assert verdict.hash_value == 'sha256'


def test_verdict_context():
    context = {'DBotScore': [
        {'Indicator': 'sha256',
         'Vendor': 'Vendors INC',
         'Score': 1}
    ],
        'File': [
            {'SHA256': 'sha256',
             'Signature': {'Publisher': 'ACME'}
             }
        ]
    }
    verdict = Verdict(context, hash_key='SHA256', hash_value='sha256')
    # _dump_test_file('verdict_context_with_hashes.json', verdict.to_context(True))
    # _dump_test_file('verdict_context_without_hashes.json', verdict.to_context(False))
    assert verdict.to_context(True) == _load_test_file('verdict_context_with_hashes.json')
    assert verdict.to_context(False) == _load_test_file('verdict_context_without_hashes.json')
