category: Analytics & SIEM
commonfields:
  id: Jira Event Collector
  version: -1
configuration:
- display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: https://<your-domain>.atlassian.net/rest/api/3/auditing/record
  display: Your server URL
  name: url
  required: true
  type: 0
- defaultvalue: GET
  display: Method request
  name: method
  required: false
  options:
  - GET
  - POST
  - PUT
  - HEAD
  - PATCH
  - DELETE
  type: 15
- display: User name
  additionalinfo: The user name (admin@example.com) and password
  name: credentials
  required: true
  type: 9
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: 3 days
  display: First fetch time (<number> <time unit>, e.g., 12 hours, 1 day, 3 months). default is 3 days.
  name: first_fetch
  required: true
  type: 0
- defaultvalue: 100
  display: The maximum number of incidents per fetch. Default is 100.
  name: max_fetch
  required: true
  type: 0
description: '[Enter a comprehensive, yet concise, description of what the integration does, what use cases it is designed for, etc.]'
display: Jira Event Collector
name: Jira Event Collector
script:
  commands:
  - deprecated: false
    description: ''
    execution: false
    name: fetch-events
    arguments:
    - description: The maximum number of incidents per fetch. Default is 100.
      isArray: true
      name: max_fetch
      required: false
      secret: false
    - description: First fetch time (<number> <time unit>, e.g., 12 hours, 1 day, 3 months). default is 3 days.
      isArray: true
      name: first_fetch
      required: false
      secret: false
    outputs:
    - contextPath: Jira.id
      description: The ID of the audit record
      type: Number
    - contextPath: Jira.summary
      description: The summary of the audit record
      type: String
    - contextPath: Jira.remoteAddress
      description: The URL of the computer where the creation of the audit record was initiated
      type: String
    - contextPath: Jira.authorKey
      description: The key of the user who created the audit record
      type: String
    - contextPath: Jira.created
      description: The date and time on which the audit record was created
      type: String
    - contextPath: Jira.category
      description: The category of the audit record
      type: String
    - contextPath: Jira.eventSource
      description: The event the audit record originated from
      type: String
    - contextPath: Jira.description
      description: The description of the audit record
      type: String
    - contextPath: Jira.objectItem
      description: Details of an item associated with the changed record
      type: Unknown
    - contextPath: Jira.changedValues
      description: The list of values changed in the record event
      type: Unknown
    - contextPath: Jira.associatedItems
      description: The list of items associated with the changed record
      type: Unknown
  isfetchevents: true
  runonce: false
  script: >
    register_module_line('Jira Event Collector', 'start', __line__())

    from enum import Enum

    import urllib3



    from pydantic import BaseConfig, BaseModel, AnyUrl, Json, Field

    import requests

    from requests.auth import HTTPBasicAuth

    import dateparser

    from datetime import datetime


    urllib3.disable_warnings()


    DATETIME_FORMAT = "%Y-%m-%dT%H:%M:%S.%f"



    class Method(str, Enum):
        GET = 'GET'
        POST = 'POST'
        PUT = 'PUT'
        HEAD = 'HEAD'
        PATCH = 'PATCH'
        DELETE = 'DELETE'


    class Args(BaseModel):
        from_day = demisto.params().get('first_fetch', '3 days')
        default_from_day = datetime.now() - timedelta(days=3)
        from_: str = Field(
            datetime.strftime(dateparser.parse(from_day, settings={'TIMEZONE': 'UTC'}) or default_from_day, DATETIME_FORMAT),
            alias='from'
        )
        limit: int = 1000
        offset: int = 0


    class ReqParams(BaseModel):
        from_day = demisto.params().get('first_fetch', '3 days')
        default_from_day = datetime.now() - timedelta(days=3)
        from_: str = Field(
            datetime.strftime(dateparser.parse(from_day, settings={'TIMEZONE': 'UTC'}) or default_from_day, DATETIME_FORMAT),
            alias='from'
        )
        limit: int = 1000
        offset: int = 0


    class Request(BaseModel):
        method: Method
        url: AnyUrl
        headers: Union[Json, dict] = {}
        params: ReqParams
        insecure: bool = Field(not demisto.params().get('insecure', False), alias='verify')
        proxy: bool = Field(demisto.params().get('proxy', False), alias='proxies')
        data: Optional[str]
        auth: Optional[HTTPBasicAuth] = Field(
            HTTPBasicAuth(
                demisto.params().get('credentials', {}).get('identifier'),
                demisto.params().get('credentials', {}).get('password')
            )
        )

        class Config(BaseConfig):
            arbitrary_types_allowed = True


    class Client:
        def __init__(self, request: Request, session=requests.Session()):
            self.request = request
            self.session = session
            self._set_proxy()
            self._set_cert_verification()

        def __del__(self):
            try:
                self.session.close()
            except AttributeError as err:
                demisto.debug(f'Ignore exceptions raised due to session not used by the client. {err}')

        def call(self) -> requests.Response:
            try:
                response = self.session.request(**self.request.dict(by_alias=True))
                response.raise_for_status()
                return response
            except Exception as exc:
                msg = f'Something went wrong with the http call {exc}'
                LOG(msg)
                raise DemistoException(msg) from exc

        def prepare_next_run(self, offset: int):
            self.request.params.offset += offset

        def _set_cert_verification(self):
            if not self.request.insecure:
                skip_cert_verification()

        def _set_proxy(self):
            if self.request.proxy:
                ensure_proxy_has_http_prefix()
            else:
                skip_proxy()


    class GetEvents:
        def __init__(self, client: Client) -> None:
            self.client = client

        def call(self) -> list:
            resp = self.client.call()
            return resp.json().get('records', [])

        def _iter_events(self):
            events = self.call()

            while events:
                yield events

                self.client.prepare_next_run(self.client.request.params.limit)
                events = self.call()

        def run(self, max_fetch: int = 100) -> List[dict]:
            stored = []
            last_run = demisto.getLastRun()

            for logs in self._iter_events():
                stored.extend(logs)

                if len(stored) > max_fetch:
                    last_run['offset'] = last_run.get('offset', 0) + max_fetch
                    demisto.setLastRun(last_run)
                    return stored[:max_fetch]

            last_run['offset'] = 0
            demisto.setLastRun(last_run)
            return stored

        @staticmethod
        def events_to_incidents(events: list):
            incidents = []

            for event in events:
                incident = {
                    'name': f"Jira Audit Records - {event['summary']} - {event['id']}",
                    'occurred': event.get('created', '').removesuffix('+0000') + 'Z',
                    'rawJSON': json.dumps(event)
                }
                incidents.append(incident)

            demisto.incidents(incidents)

        @staticmethod
        def set_next_run(log: dict) -> dict:
            """
                Handles and saves the values required for next fetch.

                There are 3 values:
                    * from: From which time to fetch
                    * next_run: Time of creation of the last event fetched
                    * offset: The size of the offset (how many events to skip)

                Since the rest API returns the events in desc order (the last event returns first), We need to save the last
                event time creation in some variable (next_run) for the next fetches, in addition we need to save in another
                variable (offset) the number of how many events we already fetched to skip them in the next fetch to avoid
                duplicates, in addition we need to save the time (from) from when to fetch if there is still some incident
                to fetch with offset
            """
            last_run = demisto.getLastRun()

            if not last_run.get('next_time'):
                last_time = log.get('created', '').removesuffix('+0000')
                next_time = last_time[:-1] + str(int(last_time[-1]) + 1)

                if last_run.get('offset'):
                    last_run['next_time'] = next_time
                else:
                    last_run['from'] = next_time

            else:
                if not last_run.get('offset'):
                    last_run['from'] = last_run.pop('next_time')

            return last_run


    def main():
        # Args is always stronger. Get last run even stronger
        demisto_params = demisto.params() | demisto.args() | demisto.getLastRun()

        demisto_params['params'] = ReqParams.parse_obj(demisto_params)

        request = Request.parse_obj(demisto_params)
        client = Client(request)
        get_events = GetEvents(client)
        command = demisto.command()

        if command == 'test-module':
            get_events.run(max_fetch=1)
            demisto.results('ok')

        elif command in ('fetch-events', 'JiraEventCollector-get-events'):
            events = get_events.run(int(demisto_params.get('max_fetch', 100)))

            if events:
                demisto.setLastRun(get_events.set_next_run(events[0]))
                if command == 'fetch-events':
                    send_events_to_xsiam(events, 'Jira', 'Audit Records')
                else:
                    get_events.events_to_incidents(events)
                    command_results = CommandResults(
                        readable_output=tableToMarkdown('Jira Audit Records', events, removeNull=True, headerTransform=pascalToSpace),
                        outputs_prefix='JiraAudit.Records',
                        outputs_key_field='id',
                        outputs=events,
                        raw_response=events,
                    )

                    return_results(command_results)


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('Jira Event Collector', 'end', __line__())
  type: python
  subtype: python3
  dockerimage: demisto/fastapi:1.0.0.28667
fromversion: 5.5.0
tests:
- No tests (auto formatted)
image: data:image/png;base64,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
detaileddescription: '[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/jira-event-collector)'
