category: Analytics & SIEM
commonfields:
  id: Azure Log Analytics test
  version: -1
configuration:
- additionalinfo: Check when authenticating using the Client Credentials flow.
  display: Use Client Credentials Authorization Flow
  name: client_credentials
  required: false
  type: 8
- additionalinfo: Received from the authorization process or from the self-deployed configuration process.
  display: ID / (Client ID :For client credentials flow)
  name: auth_id
  required: true
  type: 0
- additionalinfo: Received from the authorization process or from the self-deployed configuration process (find the tenant ID in your app overview page in the Azure portal)
  display: Token / Tenant ID
  name: refresh_token
  required: true
  type: 4
- additionalinfo: Received from the authorization process or from the self-deployed configuration process.
  display: Key / (Client Secret :For client credential flow)
  name: credentials
  required: false
  type: 9
- additionalinfo: Used for certificate authentication. As appears in the "Certificates & secrets" page of the app.
  display: Certificate Thumbprint
  name: certificate_thumbprint
  required: false
  type: 4
- additionalinfo: Used for certificate authentication. The private key of the registered certificate.
  display: Private Key
  name: private_key
  required: false
  type: 14
- display: Use a self-deployed Azure application
  name: self_deployed
  required: false
  type: 8
- display: Application redirect URI (for self-deployed mode)
  name: redirect_uri
  required: false
  type: 0
- additionalinfo: Get the Authorization code from steps 3-5 in the self deployed authorization process.
  display: Authorization code
  name: auth_code
  required: false
  type: 4
- display: Subscription ID
  name: subscriptionID
  required: true
  type: 0
- display: Resource Group Name
  name: resourceGroupName
  required: true
  type: 0
- display: Workspace Name
  name: workspaceName
  required: true
  type: 0
- display: Workspace ID (the UUID of the workspace, e.g. 123e4567-e89b-12d3-a456-426614174000)
  name: workspaceID
  required: true
  type: 0
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: Log Analytics is a service that helps you collect and analyze data generated by resources in your cloud and on-premises environments.
display: Azure Log Analytics test
name: Azure Log Analytics test
script:
  commands:
  - arguments:
    - default: false
      description: The query to execute.
      isArray: false
      name: query
      required: true
      secret: false
    - default: false
      description: The timespan over which to query data. This is an ISO8601 time period value. This timespan is applied in addition to any timespans specified in the query expression.
      isArray: false
      name: timespan
      required: false
      secret: false
    - default: false
      defaultValue: '10'
      description: The amount of time (in seconds) that a request will wait for the query response before a timeout occurs.
      isArray: false
      name: timeout
      required: false
      secret: false
    deprecated: false
    description: Executes an Analytics query for data.
    execution: false
    name: azure-log-analytics-execute-query
    outputs:
    - contextPath: AzureLogAnalytics.Query.Query
      description: The executed query.
      type: String
    - contextPath: AzureLogAnalytics.Query.TableName
      description: The name of the query table.
      type: String
  - deprecated: false
    description: Tests connectivity to Azure Log Analytics.
    execution: false
    name: azure-log-analytics-test
  - arguments:
    - default: false
      defaultValue: '50'
      description: The maximum number of saved searches to return. Default is 50.
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      defaultValue: '0'
      description: The page number from which to start a search.
      isArray: false
      name: page
      required: false
      secret: false
    deprecated: false
    description: Gets the saved searches of the Log Analytics workspace.
    execution: false
    name: azure-log-analytics-list-saved-searches
    outputs:
    - contextPath: AzureLogAnalytics.SavedSearch.id
      description: The ID of the saved search.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.etag
      description: The ETag of the saved search.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.category
      description: The category of the saved search. This helps users quickly find a saved search.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.displayName
      description: Display name of the saved search.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.functionAlias
      description: The function alias if the query serves as a function.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.functionParameters
      description: 'The optional function parameters if the query serves as a function. Value should be in the following format: ''param-name1:type1 = default_value1, param-name2:type2 = default_value2''. For more examples and proper syntax please refer to https://docs.microsoft.com/en-us/azure/kusto/query/functions/user-defined-functions'
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.query
      description: The query expression for the saved search.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.tags
      description: The tags attached to the saved search.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.version
      description: The version number of the query language. The current version and default is 2.
      type: Number
    - contextPath: AzureLogAnalytics.SavedSearch.type
      description: The resource type, e.g., Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
      type: String
  - arguments:
    - default: false
      description: The ID of the saved search.
      isArray: false
      name: saved_search_id
      required: true
      secret: false
    deprecated: false
    description: Gets a specified saved search from the Log Analytics workspace.
    execution: false
    name: azure-log-analytics-get-saved-search-by-id
    outputs:
    - contextPath: AzureLogAnalytics.SavedSearch.id
      description: The ID of the saved search.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.etag
      description: The ETag of the saved search.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.category
      description: The category of the saved search. This helps users quickly find a saved search.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.displayName
      description: The display name of the saved search.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.functionAlias
      description: The function alias if the query serves as a function.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.functionParameters
      description: 'The optional function parameters if the query serves as a function. Value should be in the following format: ''param-name1:type1 = default_value1, param-name2:type2 = default_value2''. For more examples and proper syntax see the Microsoft documention, https://docs.microsoft.com/en-us/azure/kusto/query/functions/user-defined-functions'
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.query
      description: The query expression for the saved search.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.tags
      description: The tags attached to the saved search.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.version
      description: The version number of the query language. The current version and default is 2.
      type: Number
    - contextPath: AzureLogAnalytics.SavedSearch.type
      description: The resource type, e.g., Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
      type: String
  - arguments:
    - default: false
      description: The ID of the saved search.
      isArray: false
      name: saved_search_id
      required: true
      secret: false
    - default: false
      description: The ETag of the saved search. This argument is required for updating an existing saved search.
      isArray: false
      name: etag
      required: false
      secret: false
    - default: false
      description: The category of the saved search. This helps users quickly find a saved search.
      isArray: false
      name: category
      required: true
      secret: false
    - default: false
      description: The display name of the saved search.
      isArray: false
      name: display_name
      required: true
      secret: false
    - default: false
      description: The function alias if the query serves as a function.
      isArray: false
      name: function_alias
      required: false
      secret: false
    - default: false
      description: 'The optional function parameters if the query serves as a function. Value should be in the following format: ''param-name1:type1 = default_value1, param-name2:type2 = default_value2''. For more examples and proper syntax please refer to https://docs.microsoft.com/en-us/azure/kusto/query/functions/user-defined-functions.'
      isArray: false
      name: function_parameters
      required: false
      secret: false
    - default: false
      description: The query expression for the saved search.
      isArray: false
      name: query
      required: true
      secret: false
    - default: false
      description: 'The tags attached to the saved search. Value should be in the following format: ''name=value;name=value'''
      isArray: false
      name: tags
      required: false
      secret: false
    deprecated: false
    description: Creates or updates a saved search from the Log Analytics workspace.
    execution: false
    name: azure-log-analytics-create-or-update-saved-search
    outputs:
    - contextPath: AzureLogAnalytics.SavedSearch.id
      description: The ID of the saved search.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.etag
      description: The ETag of the saved search.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.category
      description: The category of the saved search. This helps users quickly find a saved search.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.displayName
      description: The display name of the saved search.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.functionAlias
      description: The function alias if the query serves as a function.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.functionParameters
      description: 'The optional function parameters if the query serves as a function. Value should be in the following format: ''param-name1:type1 = default_value1, param-name2:type2 = default_value2''. For more examples and proper syntax please refer to https://docs.microsoft.com/en-us/azure/kusto/query/functions/user-defined-functions'
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.query
      description: The query expression for the saved search.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.tags
      description: The tags attached to the saved search.
      type: String
    - contextPath: AzureLogAnalytics.SavedSearch.version
      description: The version number of the query language. The current version and default is 2.
      type: Number
    - contextPath: AzureLogAnalytics.SavedSearch.type
      description: The resource type, e.g., Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
      type: String
  - arguments:
    - default: false
      description: The ID of the saved search.
      isArray: false
      name: saved_search_id
      required: true
      secret: false
    deprecated: false
    description: Deletes a specified saved search in the Log Analytics workspace.
    execution: false
    name: azure-log-analytics-delete-saved-search
  dockerimage: demisto/crypto:1.0.0.27590
  feed: false
  isfetch: false
  longRunning: false
  longRunningPort: false
  runonce: false
  script: >
    register_module_line('Azure Log Analytics test', 'start', __line__())




    # IMPORTS


    import requests


    # Disable insecure warnings

    requests.packages.urllib3.disable_warnings()


    ''' CONSTANTS '''


    APP_NAME = 'ms-azure-log-analytics'


    API_VERSION = '2021-06-01'


    AUTHORIZATION_ERROR_MSG = 'There was a problem in retrieving an updated access token.\n'\
                              'The response from the server did not contain the expected content.'

    SAVED_SEARCH_HEADERS = [
        'etag', 'id', 'category', 'displayName', 'functionAlias', 'functionParameters', 'query', 'tags', 'version', 'type'
    ]


    LOG_ANALYTICS_RESOURCE = 'https://api.loganalytics.io'

    AZURE_MANAGEMENT_RESOURCE = 'https://management.azure.com'



    class Client:
        def __init__(self, self_deployed, refresh_token, auth_and_token_url, enc_key, redirect_uri, auth_code,
                     subscription_id, resource_group_name, workspace_name, verify, proxy, certificate_thumbprint,
                     private_key, client_credentials):

            tenant_id = refresh_token if self_deployed or client_credentials else ''
            refresh_token = get_integration_context().get('current_refresh_token') or refresh_token
            base_url = f'https://management.azure.com/subscriptions/{subscription_id}/resourceGroups/' \
                f'{resource_group_name}/providers/Microsoft.OperationalInsights/workspaces/{workspace_name}'
            self.ms_client = MicrosoftClient(
                self_deployed=self_deployed,
                auth_id=auth_and_token_url,  # client_id for client credential
                refresh_token=refresh_token,
                enc_key=enc_key,  # client_secret for client credential
                redirect_uri=redirect_uri,
                token_retrieval_url='https://login.microsoftonline.com/{tenant_id}/oauth2/token',
                grant_type=CLIENT_CREDENTIALS if client_credentials else AUTHORIZATION_CODE,  # disable-secrets-detection
                app_name=APP_NAME,
                base_url=base_url,
                verify=verify,
                proxy=proxy,
                scope='',
                tenant_id=tenant_id,
                auth_code=auth_code,
                ok_codes=(200, 204, 400, 401, 403, 404, 409),
                multi_resource=True,
                resources=[AZURE_MANAGEMENT_RESOURCE, LOG_ANALYTICS_RESOURCE],
                certificate_thumbprint=certificate_thumbprint,
                private_key=private_key
            )

        def http_request(self, method, url_suffix=None, full_url=None, params=None,
                         data=None, resource=None, timeout=10):
            if not params:
                params = {}
            if not full_url:
                params['api-version'] = API_VERSION

            res = self.ms_client.http_request(method=method,  # disable-secrets-detection
                                              url_suffix=url_suffix,
                                              full_url=full_url,
                                              json_data=data,
                                              params=params,
                                              resp_type='response',
                                              resource=resource,
                                              timeout=timeout)

            if res.status_code in (200, 204) and not res.text:
                return res

            res_json = res.json()

            if res.status_code in (400, 401, 403, 404, 409):
                code = res_json.get('error', {}).get('code', 'Error')
                error_msg = res_json.get('error', {}).get('message', res_json)
                raise ValueError(
                    f'[{code} {res.status_code}] {error_msg}'
                )

            return res_json


    ''' INTEGRATION HELPER METHODS '''



    def format_query_table(table):
        name = table.get('name')
        columns = [column.get('name') for column in table.get('columns')]
        rows = table.get('rows')
        data = [
            {k: v for k, v in zip(columns, row)} for row in rows
        ]

        return name, columns, data


    def query_output_to_readable(tables):
        readable_output = '## Query Results\n'
        tables_markdown = [tableToMarkdown(name=name,
                                           t=data,
                                           headers=columns,
                                           headerTransform=pascalToSpace,
                                           removeNull=True) for name, columns, data in tables]
        readable_output += '\n'.join(tables_markdown)

        return readable_output


    def flatten_saved_search_object(saved_search_obj):
        ret = saved_search_obj.get('properties')
        ret['id'] = saved_search_obj.get('id').split('/')[-1]
        ret['etag'] = saved_search_obj.get('etag')
        ret['type'] = saved_search_obj.get('type')
        if ret.get('tags'):
            ret['tags'] = json.dumps(ret.get('tags'))

        return ret


    def tags_arg_to_request_format(tags):
        bad_arg_msg = 'The `tags` argument is malformed. ' \
                      'Value should be in the following format: `name=value;name=value`'
        if not tags:
            return None
        try:
            tags = tags.split(';')
            tags = [tag.split('=') for tag in tags]

            for tag in tags:
                if len(tag) != 2:
                    return_error(bad_arg_msg)

            return [{
                'name': tag[0],
                'value': tag[1]
            } for tag in tags]
        except IndexError:
            return_error(bad_arg_msg)


    ''' INTEGRATION COMMANDS '''



    def test_connection(client, params):
        if params.get('self_deployed', False) and not params.get('client_credentials') and not params.get('auth_code'):
            return_error('You must enter an authorization code in a self-deployed configuration.')
        client.ms_client.get_access_token(AZURE_MANAGEMENT_RESOURCE)  # If fails, MicrosoftApiModule returns an error
        if not params.get('client_credentials'):
            if not params.get('self_deployed', False):
                try:
                    execute_query_command(client, {'query': 'Usage | take 1'})
                except Exception as e:
                    return_error('Could not authorize to `api.loganalytics.io` resource. This could be due to one of the following:'
                                 '\n1. Workspace ID is wrong.'
                                 '\n2. Missing necessary grant IAM privileges in your workspace to the AAD Application.', e)
        return_outputs('```✅ Success!```')


    def execute_query_command(client, args):
        query = args.get('query')
        timeout = int(args.get('timeout', 10))
        workspace_id = demisto.params().get('workspaceID')
        full_url = f'https://api.loganalytics.io/v1/workspaces/{workspace_id}/query'

        data = {
            "timespan": args.get('timespan'),
            "query": query,
            "workspaces": argToList(args.get('workspaces'))
        }

        remove_nulls_from_dictionary(data)

        response = client.http_request('POST', full_url=full_url, data=data,
                                       resource=LOG_ANALYTICS_RESOURCE, timeout=timeout)

        output = []

        readable_output = '## Query Results\n'
        for table in response.get('tables'):
            name, columns, data = format_query_table(table)
            readable_output += tableToMarkdown(name=name,
                                               t=data,
                                               headers=columns,
                                               headerTransform=pascalToSpace,
                                               removeNull=True)
            output.append({
                'TableName': name,
                'Data': data,
                'Query': query
            })

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureLogAnalytics.Query',
            outputs_key_field='Query',
            outputs=output,
            raw_response=response
        )


    def list_saved_searches_command(client, args):
        page = int(args.get('page'))
        limit = int(args.get('limit'))
        url_suffix = '/savedSearches'

        response = client.http_request('GET', url_suffix, resource=AZURE_MANAGEMENT_RESOURCE)
        response = response.get('value')

        from_index = min(page * limit, len(response))
        to_index = min(from_index + limit, len(response))

        output = [
            flatten_saved_search_object(saved_search) for saved_search in response[from_index:to_index]
        ]

        readable_output = tableToMarkdown('Saved searches', output,
                                          headers=SAVED_SEARCH_HEADERS,
                                          headerTransform=pascalToSpace,
                                          removeNull=True)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureLogAnalytics.SavedSearch',
            outputs_key_field='id',
            outputs=output,
            raw_response=response
        )


    def get_saved_search_by_id_command(client, args):
        saved_search_id = args.get('saved_search_id')
        url_suffix = f'/savedSearches/{saved_search_id}'

        response = client.http_request('GET', url_suffix, resource=AZURE_MANAGEMENT_RESOURCE)
        output = flatten_saved_search_object(response)

        title = f'Saved search `{saved_search_id}` properties'
        readable_output = tableToMarkdown(title, output,
                                          headers=SAVED_SEARCH_HEADERS,
                                          headerTransform=pascalToSpace,
                                          removeNull=True)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureLogAnalytics.SavedSearch',
            outputs_key_field='id',
            outputs=output,
            raw_response=response
        )


    def create_or_update_saved_search_command(client, args):
        saved_search_id = args.get('saved_search_id')
        etag = args.get('etag')
        category = args.get('category')
        display_name = args.get('display_name')
        query = args.get('query')

        if not etag and not (category and query and display_name):
            return_error('You must specify category, display_name and query arguments for creating a new saved search.')
        url_suffix = f'/savedSearches/{saved_search_id}'

        data = {
            'properties': {
                'category': category,
                'displayName': display_name,
                'functionAlias': args.get('function_alias'),
                'functionParameters': args.get('function_parameters'),
                'query': query,
                'tags': tags_arg_to_request_format(args.get('tags'))
            }
        }

        remove_nulls_from_dictionary(data.get('properties'))

        if etag:
            data['etag'] = etag

        response = client.http_request('PUT', url_suffix, data=data, resource=AZURE_MANAGEMENT_RESOURCE)
        output = flatten_saved_search_object(response)

        title = f'Saved search `{saved_search_id}` properties'
        readable_output = tableToMarkdown(title, output,
                                          headers=SAVED_SEARCH_HEADERS,
                                          headerTransform=pascalToSpace,
                                          removeNull=True)

        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='AzureLogAnalytics.SavedSearch',
            outputs_key_field='id',
            outputs=output,
            raw_response=response
        )


    def delete_saved_search_command(client, args):
        saved_search_id = args.get('saved_search_id')
        url_suffix = f'/savedSearches/{saved_search_id}'

        client.http_request('DELETE', url_suffix, resource=AZURE_MANAGEMENT_RESOURCE)

        return f'Successfully deleted the saved search {saved_search_id}.'


    def main():
        """
            PARSE AND VALIDATE INTEGRATION PARAMS
        """
        params = demisto.params()

        LOG(f'Command being called is {demisto.command()}')

        try:
            self_deployed = params.get('self_deployed', False)
            client_credentials = params.get('client_credentials', False)
            enc_key = params.get('enc_key') or (params.get('credentials') or {}).get('password')  # client_secret
            certificate_thumbprint = params.get('certificate_thumbprint')
            private_key = params.get('private_key')
            if client_credentials and not enc_key:
                raise DemistoException("Client Secret must be provided for client credentials flow.")
            if not self_deployed and not enc_key:
                raise DemistoException('Key must be provided. For further information see '
                                       'https://xsoar.pan.dev/docs/reference/articles/microsoft-integrations---authentication')  # noqa: E501
            elif not enc_key and not (certificate_thumbprint and private_key):
                raise DemistoException('Key or Certificate Thumbprint and Private Key must be provided.')

            client = Client(
                self_deployed=self_deployed,
                auth_and_token_url=params.get('auth_id'),  # client_id
                refresh_token=params.get('refresh_token'),  # tenant_id
                enc_key=enc_key,  # client_secret
                redirect_uri=params.get('redirect_uri', ''),
                auth_code=params.get('auth_code'),
                subscription_id=params.get('subscriptionID'),
                resource_group_name=params.get('resourceGroupName'),
                workspace_name=params.get('workspaceName'),
                verify=not params.get('insecure', False),
                proxy=params.get('proxy', False),
                certificate_thumbprint=certificate_thumbprint,
                private_key=private_key,
                client_credentials=client_credentials
            )

            commands = {
                'azure-log-analytics-execute-query': execute_query_command,
                'azure-log-analytics-list-saved-searches': list_saved_searches_command,
                'azure-log-analytics-get-saved-search-by-id': get_saved_search_by_id_command,
                'azure-log-analytics-create-or-update-saved-search': create_or_update_saved_search_command,
                'azure-log-analytics-delete-saved-search': delete_saved_search_command
            }

            if demisto.command() == 'test-module':
                # cannot use test module due to the lack of ability to set refresh token to integration context
                raise Exception("Please use !azure-log-analytics-test instead")

            elif demisto.command() == 'azure-log-analytics-test':
                test_connection(client, params)

            elif demisto.command() in commands:
                return_results(commands[demisto.command()](client, demisto.args()))  # type: ignore

        except Exception as e:
            return_error(f'Failed to execute {demisto.command()} command. Error: {str(e)}')



    ### GENERATED CODE ###: from MicrosoftApiModule import *  # noqa: E402

    # This code was inserted in place of an API module.

    register_module_line('MicrosoftApiModule', 'start', __line__(), wrapper=-3)

    import traceback





    import requests

    import re

    import base64

    from cryptography.hazmat.primitives.ciphers.aead import AESGCM

    from typing import Dict, Tuple, List, Optional



    class Scopes:
        graph = 'https://graph.microsoft.com/.default'
        security_center = 'https://api.securitycenter.windows.com/.default'
        security_center_apt_service = 'https://securitycenter.onmicrosoft.com/windowsatpservice/.default'
        management_azure = 'https://management.azure.com/.default'


    # authorization types

    OPROXY_AUTH_TYPE = 'oproxy'

    SELF_DEPLOYED_AUTH_TYPE = 'self_deployed'


    # grant types in self-deployed authorization

    CLIENT_CREDENTIALS = 'client_credentials'

    AUTHORIZATION_CODE = 'authorization_code'

    REFRESH_TOKEN = 'refresh_token'  # guardrails-disable-line

    DEVICE_CODE = 'urn:ietf:params:oauth:grant-type:device_code'

    REGEX_SEARCH_URL = r'(?P<url>https?://[^\s]+)'

    SESSION_STATE = 'session_state'

    TOKEN_RETRIEVAL_ENDPOINTS = {
        'com': 'https://login.microsoftonline.com',
        'gcc-high': 'https://login.microsoftonline.us',
        'dod': 'https://login.microsoftonline.us',
        'de': 'https://login.microsoftonline.de',
        'cn': 'https://login.chinacloudapi.cn',
    }

    GRAPH_ENDPOINTS = {
        'com': 'https://graph.microsoft.com',
        'gcc-high': 'https://graph.microsoft.us',
        'dod': 'https://dod-graph.microsoft.us',
        'de': 'https://graph.microsoft.de',
        'cn': 'https://microsoftgraph.chinacloudapi.cn'
    }

    GRAPH_BASE_ENDPOINTS = {
        'https://graph.microsoft.com': 'com',
        'https://graph.microsoft.us': 'gcc-high',
        'https://dod-graph.microsoft.us': 'dod',
        'https://graph.microsoft.de': 'de',
        'https://microsoftgraph.chinacloudapi.cn': 'cn'
    }



    class MicrosoftClient(BaseClient):
        def __init__(self, tenant_id: str = '',
                     auth_id: str = '',
                     enc_key: Optional[str] = '',
                     token_retrieval_url: str = '{endpoint}/{tenant_id}/oauth2/v2.0/token',
                     app_name: str = '',
                     refresh_token: str = '',
                     auth_code: str = '',
                     scope: str = '{graph_endpoint}/.default',
                     grant_type: str = CLIENT_CREDENTIALS,
                     redirect_uri: str = 'https://localhost/myapp',
                     resource: Optional[str] = '',
                     multi_resource: bool = False,
                     resources: List[str] = None,
                     verify: bool = True,
                     self_deployed: bool = False,
                     timeout: Optional[int] = None,
                     azure_ad_endpoint: str = '{endpoint}',
                     endpoint: str = 'com',
                     certificate_thumbprint: Optional[str] = None,
                     private_key: Optional[str] = None,
                     *args, **kwargs):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                multi_resource: Where or not module uses a multiple resources (self-deployed, auth_code grant type only)
                resources: Resources of the application (for multi-resource mode)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
                certificate_thumbprint: Certificate's thumbprint that's associated to the app
                private_key: Private key of the certificate
            """
            super().__init__(verify=verify, *args, **kwargs)  # type: ignore[misc]
            self.endpoint = endpoint
            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split('@')
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.tenant_id = tenant_id
                self.refresh_token = refresh_token

            else:
                self.token_retrieval_url = token_retrieval_url.format(tenant_id=tenant_id,
                                                                      endpoint=TOKEN_RETRIEVAL_ENDPOINTS[self.endpoint])
                self.client_id = auth_id
                self.client_secret = enc_key
                self.tenant_id = tenant_id
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                self.scope = scope.format(graph_endpoint=GRAPH_ENDPOINTS[self.endpoint])
                self.redirect_uri = redirect_uri
                if certificate_thumbprint and private_key:
                    try:
                        import msal  # pylint: disable=E0401
                        self.jwt = msal.oauth2cli.assertion.JwtAssertionCreator(
                            private_key,
                            'RS256',
                            certificate_thumbprint
                        ).create_normal_assertion(audience=self.token_retrieval_url, issuer=self.client_id)
                    except ModuleNotFoundError:
                        raise DemistoException('Unable to use certificate authentication because `msal` is missing.')
                else:
                    self.jwt = None

            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify
            self.azure_ad_endpoint = azure_ad_endpoint.format(endpoint=TOKEN_RETRIEVAL_ENDPOINTS[self.endpoint])
            self.timeout = timeout  # type: ignore

            self.multi_resource = multi_resource
            if self.multi_resource:
                self.resources = resources if resources else []
                self.resource_to_access_token: Dict[str, str] = {}

        def http_request(
                self, *args, resp_type='json', headers=None,
                return_empty_response=False, scope: Optional[str] = None,
                resource: str = '', **kwargs):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Args:
                resp_type: Type of response to return. will be ignored if `return_empty_response` is True.
                headers: Headers to add to the request.
                return_empty_response: Return the response itself if the return_code is 206.
                scope: A scope to request. Currently will work only with self-deployed app.
                resource (str): The resource identifier for which the generated token will have access to.
            Returns:
                Response from api according to resp_type. The default is `json` (dict or list).
            """
            if 'ok_codes' not in kwargs and not self._ok_codes:
                kwargs['ok_codes'] = (200, 201, 202, 204, 206, 404)
            token = self.get_access_token(resource=resource, scope=scope)
            default_headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }

            if headers:
                default_headers.update(headers)

            if self.timeout:
                kwargs['timeout'] = self.timeout

            response = super()._http_request(  # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, **kwargs)

            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))
            is_response_empty_and_successful = (response.status_code == 204)
            if is_response_empty_and_successful and return_empty_response:
                return response

            # Handle 404 errors instead of raising them as exceptions:
            if response.status_code == 404:
                try:
                    error_message = response.json()
                except Exception:
                    error_message = 'Not Found - 404 Response'
                raise NotFoundError(error_message)

            try:
                if resp_type == 'json':
                    return response.json()
                if resp_type == 'text':
                    return response.text
                if resp_type == 'content':
                    return response.content
                if resp_type == 'xml':
                    ET.parse(response.text)
                return response
            except ValueError as exception:
                raise DemistoException('Failed to parse json object from response: {}'.format(response.content), exception)

        def get_access_token(self, resource: str = '', scope: Optional[str] = None) -> str:
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Args:
                resource (str): The resource identifier for which the generated token will have access to.
                scope (str): A scope to get instead of the default on the API.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = get_integration_context()
            refresh_token = integration_context.get('current_refresh_token', '')
            # Set keywords. Default without the scope prefix.
            access_token_keyword = f'{scope}_access_token' if scope else 'access_token'
            valid_until_keyword = f'{scope}_valid_until' if scope else 'valid_until'

            if self.multi_resource:
                access_token = integration_context.get(resource)
            else:
                access_token = integration_context.get(access_token_keyword)

            valid_until = integration_context.get(valid_until_keyword)

            if access_token and valid_until:
                if self.epoch_seconds() < valid_until:
                    return access_token

            if self.auth_type == OPROXY_AUTH_TYPE:
                if self.multi_resource:
                    for resource_str in self.resources:
                        access_token, expires_in, refresh_token = self._oproxy_authorize(resource_str)
                        self.resource_to_access_token[resource_str] = access_token
                        self.refresh_token = refresh_token
                else:
                    access_token, expires_in, refresh_token = self._oproxy_authorize(scope=scope)

            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(
                    refresh_token, scope, integration_context)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer
            valid_until = time_now + expires_in
            integration_context.update({
                access_token_keyword: access_token,
                valid_until_keyword: valid_until,
                'current_refresh_token': refresh_token
            })

            # Add resource access token mapping
            if self.multi_resource:
                integration_context.update(self.resource_to_access_token)

            set_integration_context(integration_context)

            if self.multi_resource:
                return self.resource_to_access_token[resource]

            return access_token

        def _oproxy_authorize(self, resource: str = '', scope: Optional[str] = None) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.
            Args:
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            oproxy_response = requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    'app_name': self.app_name,
                    'registration_id': self.auth_id,
                    'encrypted_token': self.get_encrypted(content, self.enc_key),
                    'scope': scope,
                    'resource': resource
                },
                verify=self.verify
            )

            if not oproxy_response.ok:
                msg = 'Error in authentication. Try checking the credentials you entered.'
                try:
                    demisto.info('Authentication failure from server: {} {} {}'.format(
                        oproxy_response.status_code, oproxy_response.reason, oproxy_response.text))
                    err_response = oproxy_response.json()
                    server_msg = err_response.get('message')
                    if not server_msg:
                        title = err_response.get('title')
                        detail = err_response.get('detail')
                        if title:
                            server_msg = f'{title}. {detail}'
                        elif detail:
                            server_msg = detail
                    if server_msg:
                        msg += ' Server message: {}'.format(server_msg)
                except Exception as ex:
                    demisto.error('Failed parsing error response - Exception: {}'.format(ex))
                raise Exception(msg)
            try:
                gcloud_function_exec_id = oproxy_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Oproxy server did not contain the expected content.'
                )

            return (parsed_response.get('access_token', ''), parsed_response.get('expires_in', 3595),
                    parsed_response.get('refresh_token', ''))

        def _get_self_deployed_token(self,
                                     refresh_token: str = '',
                                     scope: Optional[str] = None,
                                     integration_context: Optional[dict] = None
                                     ) -> Tuple[str, int, str]:
            if self.grant_type == AUTHORIZATION_CODE:
                if not self.multi_resource:
                    return self._get_self_deployed_token_auth_code(refresh_token, scope=scope)
                else:
                    expires_in = -1  # init variable as an int
                    for resource in self.resources:
                        access_token, expires_in, refresh_token = self._get_self_deployed_token_auth_code(refresh_token,
                                                                                                          resource)
                        self.resource_to_access_token[resource] = access_token

                    return '', expires_in, refresh_token
            elif self.grant_type == DEVICE_CODE:
                return self._get_token_device_code(refresh_token, scope, integration_context)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                if self.multi_resource:
                    expires_in = -1  # init variable as an int
                    for resource in self.resources:
                        access_token, expires_in, refresh_token = self._get_self_deployed_token_client_credentials(
                            resource=resource)
                        self.resource_to_access_token[resource] = access_token
                    return '', expires_in, refresh_token
                return self._get_self_deployed_token_client_credentials(scope=scope)

        def _get_self_deployed_token_client_credentials(self, scope: Optional[str] = None,
                                                        resource: Optional[str] = None) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Args:
                scope: A scope to add to the headers. Else will get self.scope.
                resource: A resource to add to the headers. Else will get self.resource.
            Returns:
                tuple: An access token and its expiry.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'grant_type': CLIENT_CREDENTIALS
            }

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            # Set scope.
            if self.scope or scope:
                data['scope'] = scope if scope else self.scope

            if self.resource or resource:
                data['resource'] = resource or self.resource  # type: ignore

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, ''

        def _get_self_deployed_token_auth_code(
                self, refresh_token: str = '', resource: str = '', scope: Optional[str] = None) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = assign_params(
                client_id=self.client_id,
                client_secret=self.client_secret,
                resource=self.resource if not resource else resource,
                redirect_uri=self.redirect_uri
            )

            if self.jwt:
                data.pop('client_secret', None)
                data['client_assertion_type'] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data['client_assertion'] = self.jwt

            if scope:
                data['scope'] = scope

            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                if SESSION_STATE in self.auth_code:
                    raise ValueError('Malformed auth_code parameter: Please copy the auth code from the redirected uri '
                                     'without any additional info and without the "session_state" query parameter.')
                data['grant_type'] = AUTHORIZATION_CODE
                data['code'] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_token_device_code(
                self, refresh_token: str = '', scope: Optional[str] = None, integration_context: Optional[dict] = None
        ) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {
                'client_id': self.client_id,
                'scope': scope
            }

            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                data['grant_type'] = DEVICE_CODE
                if integration_context:
                    data['code'] = integration_context.get('device_code')

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))
            refresh_token = response_json.get('refresh_token', '')

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix):]
            return ''

        @staticmethod
        def error_parser(error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                demisto.error(str(response))
                inner_error = response.get('error', {})
                if isinstance(inner_error, dict):
                    err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
                else:
                    err_str = inner_error
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utcfromtimestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utcfromtimestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: Optional[str]) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(f"Error in Microsoft authorization: {str(err)}"
                                 f" Please check authentication related parameters.", error=traceback.format_exc())

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
            return encrypted

        @staticmethod
        def _add_info_headers() -> Dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                headers = get_x_content_info_headers()
            except Exception as e:
                demisto.error('Failed getting integration info: {}'.format(str(e)))

            return headers

        def device_auth_request(self) -> dict:
            response_json = {}
            try:
                response = requests.post(
                    url=f'{self.azure_ad_endpoint}/organizations/oauth2/v2.0/devicecode',
                    data={
                        'client_id': self.client_id,
                        'scope': self.scope
                    },
                    verify=self.verify
                )
                if not response.ok:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')
            set_integration_context({'device_code': response_json.get('device_code')})
            return response_json

        def start_auth(self, complete_command: str) -> str:
            response = self.device_auth_request()
            message = response.get('message', '')
            re_search = re.search(REGEX_SEARCH_URL, message)
            url = re_search.group('url') if re_search else None
            user_code = response.get('user_code')

            return f"""### Authorization instructions
    1. To sign in, use a web browser to open the page [{url}]({url})

    and enter the code **{user_code}** to authenticate.

    2. Run the **{complete_command}** command in the War Room."""



    class NotFoundError(Exception):
        """Exception raised for 404 - Not Found errors.

        Attributes:
            message -- explanation of the error
        """

        def __init__(self, message):
            self.message = message

    register_module_line('MicrosoftApiModule', 'end', __line__(), wrapper=1)

    ### END GENERATED CODE ###



    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('Azure Log Analytics test', 'end', __line__())
  subtype: python3
  type: python
tests:
- No test
fromversion: 5.0.0
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAA0CAYAAAAjfRLqAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH4wMFBCEDPuWl6wAAEL5JREFUeNrt3Xu0JFV1BvBf9Z0XI8OAMg6IjshjkMEHGBUQUVCBOELQBIhGYhI1DyRRxMAMGjWiBnpwrayoy0QxyySoEURFAR+AUZDIQ1DRmQZ5RAQVhocwAvPwzu3KH7vqVt++fW9Xdd/HoP2tVeverj516tSpffbZ+9v7nE5sC6g38v92w8G42KoVW2a7WQM8/lCb7Qa0CPNy/DNSDIR5gJ6QzOrdC2E+BP+CTTgaG0bLNFPO2G9WmznA4wezp6FDmGs4Hudhf/w7Nli1AuZisdrsjrkBHl+YeWk5ex1JAgvwFrwLT8SNeCXuz0oegD/Nvt+UCfkAA0yKmdXQ9UYuzE/C2figEOYmztNM7g/BTeBI/BV+f7Y7aYDHD2ZOoAt7eQ98HH8ntDT8BF9US7OP6SKsxBPwDuzccv0AA0yImRHoQhgPxKfxRy33TvHf+LlVK/KyB2QHHCRMjwEG6IrpF+gQ0ASvFsJ8cFuJn+F8IdgkEsF0LMq+H8LJ2GegpQfohukT6DWNXJjnC4E8F3t1KPkF3D7q9KWW4Ki2MnvibzHHmoFQDzAxpkeg641c3+6I92MNdu5Q8l6htZuj1/Ei7NOh7J/gEKkBBpgQUy/QhVmwDP+KU7HdBKUvxtoWSm4IfyC0ejueKBzE7QemxwATYWoFuhC054lgyWuFkHbCQ/hPbAXnNODpOHySOxwpbPEBBuiIqRPoekPGH6/EZ/CSLldchhtGtXMYHYfjaZNcMx+n4CkDLT1AJ8yZklpCuOaS/rmwmZd2ueJRfMrYJKT5wtwY6nLtAXijCMpsexb1RANtEOmcEfSvoeMF7oD3iGy5bsIMV+Hq0TyNqOOZxlN6E7X5L/GsbVRL17BYOMQ7YeFsN+h3Cf0JdAjUjkKQV4vIXjdswX/gMaft29qKo3RmQjphGd6Geeo3z2yPde+Plwhz6n/wzaxvtuuj1gEqoD+BThMiivdnypsv1+PyMWlRTYvwKtWSpY7D4duY1VETjvALFdHOE/DsbXQ2+a1D7wJdb5CkecCjm92bY6vQzg87fUVRz9hQd1ksFjTe4m1CWKINy/CKtm92FL7BIA92BtCbQNd/QgjxW8RKk7L4ES5pO5cI7byoQj05DsMJWQbftoBXYPfs/y1y7iZC+UusWTfb7futR48aeoRINKqSNNTEp6WfvK/N4+8U6i6LuXirNF22DWjp7QRHns9W/4sHs//3xaGZiTbANKK6QIfgLBQRwCUVrrwVX5C8ub2ugwTD0Sv2w1+jNmtCHfd9loKlGRYZhHmD5uEPxQAcYBrRKw99tAiglEWKz+HuNu08Wai7LBL8Bb6EG6atp7rjGBGeh5/iq9gFL83OHYa91RuN32lOejQAl5LOZfXeJa9pR8KqfcedrSbQUfGT8XbVqKi7hUCnbXU9zeSh7rLYNWvTm9Qbm2dBYJaIQZ7jCtwj6LtTBR+9K1ZK03LTyFTNNqvGON8Tf1+1LZ2u61SuhpHUGD8n2Uo6RDJc5Z7zxAyXYjNpc7RMS1uqauhEUHQvqHjdF3Bbh044TORvTAWOxQX48hTVVw7RqYcgf7hNIukqxVp8T+SgJDhWkpyrdVX7xNhN2N79YK3IaJTd/7kKrv8B4aQ3S9Szk0j9zVSr2/Bwh3JDYrHzTtnn9fhxJsyL8HK8WDq0Ix7B5/HdCfqUUJ4vFdz+HlkdTfwS1+IyQ24Jxg2nr6gg0EU072+Up+nyhzqvQ8fNF9N0lbomwxOENrxavfHgDGrpOXiNwmxai+uz1Tcb8RXBftQENflC9cblJdp3hMhW7BVbRcrtxS3tfI9YiAzfEBz5b0rUdaigW4eEf3Aivt6h3HyxVvTF2efPu6L5Bi+rPUOkEB+tWHZHJKiNFegih/54sUzvAJ19j9fhTiPOxcekMcDKOYWRVD9HcM57VOzYS/DjDi9wD5H7PJV4EV4/YzRedP4exppNXyP5FXID6wqhUYhB9xrl+n1IvPxej6txTVudc1u+n1fhSecJ3n+H7O+cLmXze8zxstpSfFQEwhaMK31OC5UZ/bkIHxDrTl+oEOYRbBYDKsfuOBMfxpPUGyU1dLyYQ8WoqIKHtaaIjsWDuEk4TlOFOThZmn5VvXH7DGnpo4R5QGicr466CqtXUG/cgSvx+qzMkVhmTePO0eBSZ/yfcHQTRVCm9W/r+QWCYcnzRu4U2z880FZnP2HVtIc6EpwkCITN+L5gfpqCndo4WjKEeYGYRU5RDJo78UUxOH+F7bNn/WM8Qwz8E3Ef3tldoItRkzs3VXC5fPodj/tEpG9XPKePjm7HchHwOc05jRGnTatQby+451zjfs/42WirsOuPF9prd7xC6pNd6v62SOJKRuU2TXMxjhP5KkzepJjtNuH9mrXvq01qHs/ENLanEL5figF2kcTD0hTJYixo4+aPE8v1crm8HKdJ3NQ2jL4i/KWPZs+d98G3yvLQrxY2XRU8ZnyKaDvWiYHyy1I1lseJOKiUu9MripD987MzTVwsTTeOKbdxiJj+b8vODAmzoxtLlIppdivp1vg7egxLDYvp97lYldWXihnxs2rNTkxEPxq6lwGwv3BCV8tTHtLRqjZgvSTl7LXETN3Knl0v/LUQ5lUriiPwA5wmfDQixeDkyTV0vLSniCmgKlf8HVw1YTcUWxZ8E2eI0dZL+LsTlmSd8wP1mzd24iunAMFahF1J0HRXqLXpiPftQ71xr6Dw8k36DsZz1BvXTWgWdTOXou+WiLzwnCm6Hv+EzduAMBP279dw4aTPVL8Z6UoxOAkG5Exhdo2/rpCd64SP9qbsm8O6aehcle9f8UG2CO382KR2YtHQzwoveLhbxRWwEseUY6Uqon4LYSq9suXsd3CH0zsOnlSwDY9mn3fST8JSfdRJP1VQYcQWau8yPng1EVpt8OnCsHi3XbZyS9sXd1wt0m91GfAjwizJfbTtJtbQ0WnPFsn0VUPk38PlkhJKIUbbVpE3vAxvNjUdvR3eTvIt9cZ9U+sgNgl+NA9zDQs7ufOAjGe8ET9UUFpH48PqjfWV2vaBn8hyaY4VvkItu++H8K0uV890ru0vcF0J6dlVoTRTQQluQpkA063CvF3MRPTLmltIm/PwVpOv8euErcKOe8jpJbfBjRf+GN6Npxqr+frB80Ug6EOm9mXOE3ZwTindJhemiV/Ar3GRcGJqgtM/VD4dl8XcEdm1ZyrMna/g39DsMjha+6CK0uhVwfwU60s45rsr8oJSkfj2DyXvsVQLT91ZoNMmwa0e18NDrFWQ+eURQr1eTKO7qJ4f3QlDgja6RL1x85Ro6RDYfYxdBPxQ1l8jxtJbrYKQiFljS/Y3T1iaWLN3vvciIcz5w9wiqK5fV3y+mWA5fl3y2ZYqOOqaCAj1hPECHZ22WAjW4or1RYpoLVk/uryqCtIaSfMW4YSeJ0yQfvEMERA6xdnrhq3uc/P0uYsZ3rBShGVzHKzItJtoJsjDxq0T8GFYrt5YV9IJrAnP/9XZ2UfwXqmGtJRV2K6hp1uoWwf4ZJhvinYgGC/QNTQdLzq7Km7HhZo9zu6rnxkvbm7zKsO11fiYoGP6xetwoSTpZmN2x/CGxcY7dL2+jF2wkqRs5v/h+HsxxTbxCXxJkvXd5Ej1bnZVEfx0gv8nw1bFjDYsCIU7utTdsf6xAl1v0LRM2M5VQqN55Z/DXX1N7QUlc4Gw38/UX3opwSqcihvUG4/03L5o14HGsj53i6m1LBJhMy40Sv2lnzBZwlKRmfhBxcxwFc7BcIXnaaV8ZmLn2bIC/YgQ6nygXijYi8po19DFFgHV8XOR1N6/8xVCPYKPCLPjJP2/gCPwGpL/6qOOmpju8xDzQ2KPkJsq1rEGb8g+H4AD1RuXTZKSuUA4SQdmZ38hKLoqDEkeqMkxT5nEsCJZqBfzpKws3COYih2zdu2NMglc41AISTR8f/GCemn8F3HrlNFjUc8m/KNenMzxmI+3kfa261KhJVsjpjeIbLH7KxzrRdrk5qyOhSZKWFozuunliYrlbltwlsQ11VRH2lTw4ISm36Hkxc/Ru71dppV3C6GW3eclmKtefQ1maOhiFJ4iIoNVcZ/OKaL9ITT1A8Ju3FVkX/WD/UWg6AN6m0leLpxM2fWXYmPlQVxvXCPC/r+XnYmEpfq6O61qcVrDqnyB0M55SPgCfEoqtbrKfRO4q+XEbnimeuOeiSN4DaLfj+ylsyv08QMiypkzCYfjeSTXlezP0X9bTY5sSu4Jl+KmacluqyU009vFxjKfUT19dUxtwqT6snrjRxXbuyDrn3yaXi9SQ6sj9aDEpQqBfjqOIDl3tEy8pJ2NDW3fhPdhozThrG6b7KSckT1jKIebhNM1V6SyHo+r1BsjY/pizbp8z5V8eVvZjmp3PMsK9IiY4U8QA/fJIv/jjeqNh0bb34qz1mpLM9gd9+cLS3OnafseXs8GkXiytYdru6Og/64VySgP9l4ZwmyIXZfWlNx1afwiWMLUuK2nQRyT9yUiHZL2hKUitP0ORWj7QbxL6o7Q3Cm1Lsd4C/lGeX5E4HXZEXKQHyHMc4Sd/w4F5Tg9GNlChLpbHcFjRPR4j9E+aT0KYd4ta+O5WDIno+leK6JWveAKE6eITg0K5uMiEUk8W3/bax2Hz0vTr5crniI5Rvx6F6FRLlFutcdEz7NWDNJ8sfFBeK5649rsc2tom3CaXikZ3cimm4Btkfq4yCfO8QvBRL1HCOmO4gdPnyf8lHuy80/L+ui1QptfKsyOftmmznjnAdQbjwpGaz+RdjqkWO53vsiVuTd77u2FRn6RsCxWiJ82MUfTcvnPPVTHRsEZbu7h2moIIWiKlQzLhL3f6/KtHcSMdI16Y0P3wZjsLDbDyXEXvq02og9sElHCo7Ln2AnHMnItQ/saG9qWPfPJFerfLIT0zpZzqQiR54JArFR/u9gK4pGW/snTUT8ikoXK7p3Si8kR3lctvZHkLdk98w2MVsjNrHBqU2H+PcFYmX0YwzWhrpcLrVP1uBJXTuuvvbZOM4Etgvk4X39O6GE4IZLNu+IQY6nMK3GX057d+93jvlcY66i9iqElQjP2O+WNH20xcO8VNOgF8gSgwEIRgl4qhPkBnCXyax5TzBSTvex2G7q8YJwx+vuUl4nVKOcby+8vFLb1UmOXga0XuUMn4d45Qkt8o8LN80YnIo/g0Z7C3J0wOZ22ndAmuwmm4VFht1cNAOWIXZeS5BvqjW7BoLvEgs28j76rk8BUwer9qDd+JmbHp2Znt4i+/ZowD/rBsE7RtiQlTe4Q9OzLRCLYvlnfJsJWv1Es/7o2e861ilhAU6wWn+ieHxJmTZLdv7yWLkzLHwpn9CDxw6v7i+Sloaw9jwoT43oRYGpk95b0vf9DSjX6SCu/2glzxZS3i/Dul4vssr3EtPtkkaAzFZGuVK6FfjOv6d17dS5Vdl+KqpiJnZ46tbO1/5MaaXOhwifZpHWtXyFk3evtVC7bXqASxsvHgqx9+YD6TdbOlhl6iFX7THNySv1Wk5AfiTDulwgNtZcQ3OXC4N9VETmaTtwjcjNumMGtD7YNTKZYtpW+6Dbo29o5dQI9+Y0XCKfnKYKG2Sc79hQmxJOU2yx9uvAZsbBgNnZdGmAK0d9vrLQKcZqQpPOEubBUmAt7C8Hd21hzYao2l5kqHIsLJS6a7YYM0B/6/dGgeYKz3FeSPkswAXsLE+KJOm0ssm1ie5wk9U0FdTXA4xD/D/Hsm53QCsjKAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE5LTAzLTA1VDA0OjMzOjAzLTA1OjAwbx74lgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxOS0wMy0wNVQwNDozMzowMy0wNTowMB5DQCoAAAAASUVORK5CYII=
detaileddescription: "Log Analytics is a service that helps you collect and analyze data generated by resources in your cloud and on-premises environments.\n\nFull documentation for this integration is available in the [reference docs](https://xsoar.pan.dev/docs/reference/integrations/azure-log-analytics).\n\n\n## Authorize Cortex XSOAR for Azure Log Analytics\n\nYou need to grant Cortex XSOAR authorization to access Azure Log Analytics.\n\n1. Access the [authorization flow](https://oproxy.demisto.ninja/ms-azure-log-analytics). \n2. Click the **Start Authorization Process** button, and you will be prompted to grant Cortex XSOAR permissions for your Azure Service Management. \n3. Click the **Accept** button, and you will receive your ID, token, and key. You will need to enter these when you configure the Azure Log Analytics integration instance in Cortex XSOAR.\n\n## Authorize Cortex XSOAR for Azure Log Analytics (self-deployed configuration)\n\nFollow these steps for a self-deployed configuration.\n\n1. To use a self-configured Azure application, you need to add a new Azure App Registration in the Azure Portal. To add the registration, refer to the following [Microsoft article](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app).\n2. Make sure the following permissions are granted for the app registration:\n   - Azure Service Management - permission `user_impersonation` of type `Delegated`\n   - Log Analytics API - permission `Data.Read` of type `Delegated`\n3. Copy the following URL and replace the ***CLIENT_ID*** and ***REDIRECT_URI*** with your own client ID and redirect URI, accordingly.\n```https://login.microsoftonline.com/common/oauth2/authorize?response_type=code&resource=https://management.core.windows.net&client_id=CLIENT_ID&redirect_uri=REDIRECT_URI```\n4. Enter the link and you will be prompted to grant Cortex XSOAR permissions for your Azure Service Management. You will be automatically redirected to a link with the following structure:\n```REDIRECT_URI?code=AUTH_CODE&session_state=SESSION_STATE```\n5. Copy the ***AUTH_CODE*** (without the “code=” prefix, and the session_state parameter) and paste it in your instance configuration under the **Authorization code** parameter. \n6. Enter your client ID in the ***ID*** parameter. \n7. Enter your client secret in the ***Key*** parameter.\n8. Enter your tenant ID in the ***Token*** parameter.\n9. Enter your redirect URI in the ***Redirect URI*** parameter.\n\n## Get the additional instance parameters\n\nTo get the ***Subscription ID***, ***Workspace Name***, ***Workspace ID*** and ***Resource Group*** parameters, navigate in the Azure Portal to ***Log Analytics workspaces > YOUR-WORKSPACE > Settings*** and click on ***Workspace Settings*** tab.\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/azure-log-analytics-test)"
